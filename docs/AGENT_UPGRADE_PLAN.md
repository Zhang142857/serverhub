# Agentç³»ç»Ÿå‡çº§æ–¹æ¡ˆ

> å¢å¼ºAI Agentèƒ½åŠ›ï¼Œå®ç°å¤šAgentåä½œå’Œæ™ºèƒ½å·¥å…·å¸‚åœº

---

## ğŸ¯ å‡çº§ç›®æ ‡

1. **å¤šAgentåä½œ** - æ”¯æŒä¸»Agentè°ƒç”¨å­Agentå®Œæˆå¤æ‚ä»»åŠ¡
2. **Agentå·¥å…·å¸‚åœº** - æ’ä»¶å¯æ³¨å†Œå·¥å…·ï¼ŒAgentæ™ºèƒ½å‘ç°å’Œä½¿ç”¨
3. **é•¿æœŸè®°å¿†ç³»ç»Ÿ** - å‘é‡æ•°æ®åº“å­˜å‚¨å†å²å¯¹è¯å’ŒçŸ¥è¯†
4. **è‡ªä¸»è§„åˆ’å¢å¼º** - æ›´å¼ºçš„ä»»åŠ¡åˆ†è§£å’Œæ‰§è¡Œèƒ½åŠ›
5. **å®‰å…¨æœºåˆ¶å®Œå–„** - å±é™©æ“ä½œç¡®è®¤ã€å®¡è®¡æ—¥å¿—ã€å›æ»šæœºåˆ¶

---

## ğŸ—ï¸ æ¶æ„å‡çº§

### å½“å‰æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         AI Gateway                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ReAct Engine                    â”‚   â”‚
â”‚  â”‚  - Think â†’ Act â†’ Observe         â”‚   â”‚
â”‚  â”‚  - å•Agentæ‰§è¡Œ                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Tool Registry (40+ tools)       â”‚   â”‚
â”‚  â”‚  - system, docker, file, etc.    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å‡çº§åæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agent Orchestrator                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Multi-Agent Coordinator                             â”‚   â”‚
â”‚  â”‚  - ä»»åŠ¡åˆ†è§£å’Œåˆ†é…                                      â”‚   â”‚
â”‚  â”‚  - Agenté—´é€šä¿¡                                        â”‚   â”‚
â”‚  â”‚  - ç»“æœèšåˆ                                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Main Agent   â”‚  â”‚ Sub Agent 1  â”‚  â”‚ Sub Agent 2  â”‚      â”‚
â”‚  â”‚ (ReAct)      â”‚  â”‚ (Specialist) â”‚  â”‚ (Specialist) â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Enhanced Tool Registry                              â”‚   â”‚
â”‚  â”‚  - æ ¸å¿ƒå·¥å…· (40+)                                     â”‚   â”‚
â”‚  â”‚  - æ’ä»¶å·¥å…· (åŠ¨æ€æ³¨å†Œ)                                â”‚   â”‚
â”‚  â”‚  - å·¥å…·åˆ†ç±»å’Œæœç´¢                                     â”‚   â”‚
â”‚  â”‚  - æ™ºèƒ½æ¨è                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Memory System                                       â”‚   â”‚
â”‚  â”‚  - çŸ­æœŸè®°å¿† (ä¼šè¯å†å²)                                â”‚   â”‚
â”‚  â”‚  - é•¿æœŸè®°å¿† (å‘é‡æ•°æ®åº“)                              â”‚   â”‚
â”‚  â”‚  - çŸ¥è¯†å›¾è°±                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Security & Audit                                    â”‚   â”‚
â”‚  â”‚  - æ“ä½œå®¡è®¡æ—¥å¿—                                       â”‚   â”‚
â”‚  â”‚  - å±é™©æ“ä½œç¡®è®¤                                       â”‚   â”‚
â”‚  â”‚  - å›æ»šæœºåˆ¶                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤ å¤šAgentåä½œç³»ç»Ÿ

### Agentç±»å‹å®šä¹‰

```typescript
/**
 * Agentç±»å‹
 */
export enum AgentType {
  /** ä¸»Agent - è´Ÿè´£ä»»åŠ¡è§„åˆ’å’Œåè°ƒ */
  MAIN = 'main',
  
  /** ä¸“å®¶Agent - ä¸“æ³¨ç‰¹å®šé¢†åŸŸ */
  SPECIALIST = 'specialist',
  
  /** å·¥å…·Agent - æ‰§è¡Œç‰¹å®šå·¥å…· */
  TOOL = 'tool'
}

/**
 * Agentå®šä¹‰
 */
export interface AgentDefinition {
  id: string
  name: string
  type: AgentType
  description: string
  capabilities: string[]
  tools: string[]
  model?: string
  temperature?: number
}
```

### Agentåè°ƒå™¨

```typescript
/**
 * Agentåè°ƒå™¨ - ç®¡ç†å¤šä¸ªAgentçš„åä½œ
 */
export class AgentOrchestrator {
  private agents: Map<string, Agent> = new Map()
  private taskQueue: TaskQueue
  private messageRouter: MessageRouter

  /**
   * æ³¨å†ŒAgent
   */
  registerAgent(agent: Agent): void {
    this.agents.set(agent.id, agent)
  }

  /**
   * æ‰§è¡Œä»»åŠ¡ - è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„Agent
   */
  async executeTask(task: Task): Promise<TaskResult> {
    // 1. ä»»åŠ¡åˆ†æ
    const analysis = await this.analyzeTask(task)
    
    // 2. é€‰æ‹©Agent
    const agent = this.selectAgent(analysis)
    
    // 3. å¦‚æœéœ€è¦åä½œï¼Œåˆ†è§£ä»»åŠ¡
    if (analysis.requiresCollaboration) {
      return await this.executeCollaborativeTask(task, analysis)
    }
    
    // 4. å•Agentæ‰§è¡Œ
    return await agent.execute(task)
  }

  /**
   * åä½œä»»åŠ¡æ‰§è¡Œ
   */
  private async executeCollaborativeTask(
    task: Task,
    analysis: TaskAnalysis
  ): Promise<TaskResult> {
    // 1. åˆ†è§£ä»»åŠ¡
    const subtasks = await this.decomposeTask(task, analysis)
    
    // 2. åˆ†é…ç»™ä¸åŒçš„Agent
    const assignments = this.assignTasks(subtasks)
    
    // 3. å¹¶è¡Œæˆ–ä¸²è¡Œæ‰§è¡Œ
    const results = await this.executeSubtasks(assignments)
    
    // 4. èšåˆç»“æœ
    return await this.aggregateResults(results)
  }

  /**
   * Agenté—´æ¶ˆæ¯ä¼ é€’
   */
  async sendMessage(
    from: string,
    to: string,
    message: AgentMessage
  ): Promise<void> {
    await this.messageRouter.route(from, to, message)
  }
}
```

### ä¸“å®¶Agentç¤ºä¾‹

```typescript
/**
 * Dockerä¸“å®¶Agent
 */
export class DockerExpertAgent extends Agent {
  constructor() {
    super({
      id: 'docker-expert',
      name: 'Dockerä¸“å®¶',
      type: AgentType.SPECIALIST,
      description: 'ä¸“æ³¨äºDockerå®¹å™¨ç®¡ç†å’Œæ•…éšœæ’æŸ¥',
      capabilities: [
        'container-management',
        'image-management',
        'network-troubleshooting',
        'performance-optimization'
      ],
      tools: [
        'docker_list_containers',
        'docker_inspect',
        'docker_logs',
        'docker_stats',
        'docker_exec'
      ]
    })
  }

  async execute(task: Task): Promise<TaskResult> {
    // ä½¿ç”¨ReActæ¨¡å¼æ‰§è¡ŒDockerç›¸å…³ä»»åŠ¡
    return await this.reactLoop(task)
  }
}

/**
 * ç½‘ç»œä¸“å®¶Agent
 */
export class NetworkExpertAgent extends Agent {
  constructor() {
    super({
      id: 'network-expert',
      name: 'ç½‘ç»œä¸“å®¶',
      type: AgentType.SPECIALIST,
      description: 'ä¸“æ³¨äºç½‘ç»œé…ç½®å’Œæ•…éšœè¯Šæ–­',
      capabilities: [
        'network-diagnosis',
        'firewall-management',
        'dns-management',
        'ssl-management'
      ],
      tools: [
        'network_ping',
        'network_traceroute',
        'network_port_scan',
        'firewall_list_rules',
        'dns_lookup'
      ]
    })
  }
}
```

---

## ğŸ› ï¸ å¢å¼ºçš„å·¥å…·æ³¨å†Œç³»ç»Ÿ

### å·¥å…·æ³¨å†Œä¸­å¿ƒå‡çº§

```typescript
/**
 * å¢å¼ºçš„å·¥å…·æ³¨å†Œä¸­å¿ƒ
 */
export class EnhancedToolRegistry {
  private tools: Map<string, ToolDefinition> = new Map()
  private categories: Map<string, Set<string>> = new Map()
  private pluginTools: Map<string, Set<string>> = new Map()
  private usageStats: Map<string, ToolUsageStats> = new Map()

  /**
   * æ³¨å†Œå·¥å…·ï¼ˆæ”¯æŒæ’ä»¶æ³¨å†Œï¼‰
   */
  registerTool(tool: ToolDefinition, pluginId?: string): void {
    this.tools.set(tool.name, tool)
    
    // åˆ†ç±»ç´¢å¼•
    if (!this.categories.has(tool.category)) {
      this.categories.set(tool.category, new Set())
    }
    this.categories.get(tool.category)!.add(tool.name)
    
    // æ’ä»¶å·¥å…·ç´¢å¼•
    if (pluginId) {
      if (!this.pluginTools.has(pluginId)) {
        this.pluginTools.set(pluginId, new Set())
      }
      this.pluginTools.get(pluginId)!.add(tool.name)
    }
    
    // åˆå§‹åŒ–ä½¿ç”¨ç»Ÿè®¡
    this.usageStats.set(tool.name, {
      callCount: 0,
      successCount: 0,
      failureCount: 0,
      avgExecutionTime: 0
    })
  }

  /**
   * æ™ºèƒ½æœç´¢å·¥å…·
   */
  searchTools(query: string, context?: SearchContext): ToolDefinition[] {
    const results: Array<{ tool: ToolDefinition; score: number }> = []
    
    for (const tool of this.tools.values()) {
      let score = 0
      
      // åç§°åŒ¹é…
      if (tool.name.includes(query)) score += 10
      if (tool.displayName.includes(query)) score += 8
      
      // æè¿°åŒ¹é…
      if (tool.description.includes(query)) score += 5
      
      // åˆ†ç±»åŒ¹é…
      if (context?.category && tool.category === context.category) score += 3
      
      // ä½¿ç”¨é¢‘ç‡åŠ æƒ
      const stats = this.usageStats.get(tool.name)
      if (stats) {
        score += Math.log(stats.callCount + 1)
      }
      
      if (score > 0) {
        results.push({ tool, score })
      }
    }
    
    // æŒ‰åˆ†æ•°æ’åº
    results.sort((a, b) => b.score - a.score)
    
    return results.map(r => r.tool)
  }

  /**
   * è·å–åˆ†ç±»ä¸‹çš„å·¥å…·
   */
  getToolsByCategory(category: string): ToolDefinition[] {
    const toolNames = this.categories.get(category) || new Set()
    return Array.from(toolNames)
      .map(name => this.tools.get(name))
      .filter(Boolean) as ToolDefinition[]
  }

  /**
   * è·å–æ’ä»¶çš„å·¥å…·
   */
  getPluginTools(pluginId: string): ToolDefinition[] {
    const toolNames = this.pluginTools.get(pluginId) || new Set()
    return Array.from(toolNames)
      .map(name => this.tools.get(name))
      .filter(Boolean) as ToolDefinition[]
  }

  /**
   * æ¨èå·¥å…·
   */
  recommendTools(context: RecommendContext): ToolDefinition[] {
    // åŸºäºä¸Šä¸‹æ–‡æ¨èç›¸å…³å·¥å…·
    const recommendations: Array<{ tool: ToolDefinition; relevance: number }> = []
    
    for (const tool of this.tools.values()) {
      let relevance = 0
      
      // åŸºäºä»»åŠ¡ç±»å‹
      if (context.taskType && tool.category === context.taskType) {
        relevance += 5
      }
      
      // åŸºäºå†å²ä½¿ç”¨
      if (context.recentTools?.includes(tool.name)) {
        relevance += 3
      }
      
      // åŸºäºæˆåŠŸç‡
      const stats = this.usageStats.get(tool.name)
      if (stats && stats.callCount > 0) {
        const successRate = stats.successCount / stats.callCount
        relevance += successRate * 2
      }
      
      if (relevance > 0) {
        recommendations.push({ tool, relevance })
      }
    }
    
    recommendations.sort((a, b) => b.relevance - a.relevance)
    
    return recommendations.slice(0, 10).map(r => r.tool)
  }

  /**
   * è®°å½•å·¥å…·ä½¿ç”¨
   */
  recordUsage(
    toolName: string,
    success: boolean,
    executionTime: number
  ): void {
    const stats = this.usageStats.get(toolName)
    if (!stats) return
    
    stats.callCount++
    if (success) {
      stats.successCount++
    } else {
      stats.failureCount++
    }
    
    // æ›´æ–°å¹³å‡æ‰§è¡Œæ—¶é—´
    stats.avgExecutionTime = 
      (stats.avgExecutionTime * (stats.callCount - 1) + executionTime) / 
      stats.callCount
  }

  /**
   * å¸è½½æ’ä»¶å·¥å…·
   */
  unregisterPluginTools(pluginId: string): void {
    const toolNames = this.pluginTools.get(pluginId)
    if (!toolNames) return
    
    for (const toolName of toolNames) {
      this.tools.delete(toolName)
      this.usageStats.delete(toolName)
      
      // ä»åˆ†ç±»ç´¢å¼•ä¸­ç§»é™¤
      for (const categoryTools of this.categories.values()) {
        categoryTools.delete(toolName)
      }
    }
    
    this.pluginTools.delete(pluginId)
  }
}
```

---

## ğŸ§  é•¿æœŸè®°å¿†ç³»ç»Ÿ

### è®°å¿†æ¶æ„

```typescript
/**
 * è®°å¿†ç±»å‹
 */
export enum MemoryType {
  /** çŸ­æœŸè®°å¿† - å½“å‰ä¼šè¯ */
  SHORT_TERM = 'short_term',
  
  /** é•¿æœŸè®°å¿† - æŒä¹…åŒ–å­˜å‚¨ */
  LONG_TERM = 'long_term',
  
  /** å·¥ä½œè®°å¿† - ä»»åŠ¡æ‰§è¡ŒæœŸé—´ */
  WORKING = 'working'
}

/**
 * è®°å¿†é¡¹
 */
export interface MemoryItem {
  id: string
  type: MemoryType
  content: string
  embedding?: number[]
  metadata: {
    timestamp: number
    source: string
    importance: number
    tags: string[]
  }
}

/**
 * è®°å¿†ç³»ç»Ÿ
 */
export class MemorySystem {
  private shortTermMemory: MemoryItem[] = []
  private vectorStore: VectorStore
  private knowledgeGraph: KnowledgeGraph

  constructor() {
    this.vectorStore = new VectorStore()
    this.knowledgeGraph = new KnowledgeGraph()
  }

  /**
   * å­˜å‚¨è®°å¿†
   */
  async store(item: MemoryItem): Promise<void> {
    if (item.type === MemoryType.SHORT_TERM) {
      this.shortTermMemory.push(item)
      
      // çŸ­æœŸè®°å¿†å®¹é‡é™åˆ¶
      if (this.shortTermMemory.length > 100) {
        // å°†é‡è¦çš„è®°å¿†è½¬ä¸ºé•¿æœŸè®°å¿†
        await this.consolidateMemory()
      }
    } else if (item.type === MemoryType.LONG_TERM) {
      // ç”Ÿæˆembedding
      item.embedding = await this.generateEmbedding(item.content)
      
      // å­˜å‚¨åˆ°å‘é‡æ•°æ®åº“
      await this.vectorStore.add(item)
      
      // æ›´æ–°çŸ¥è¯†å›¾è°±
      await this.knowledgeGraph.addNode(item)
    }
  }

  /**
   * æ£€ç´¢ç›¸å…³è®°å¿†
   */
  async retrieve(query: string, limit: number = 5): Promise<MemoryItem[]> {
    // 1. ç”ŸæˆæŸ¥è¯¢embedding
    const queryEmbedding = await this.generateEmbedding(query)
    
    // 2. å‘é‡æœç´¢
    const vectorResults = await this.vectorStore.search(queryEmbedding, limit)
    
    // 3. ç»“åˆçŸ¥è¯†å›¾è°±
    const graphResults = await this.knowledgeGraph.findRelated(query)
    
    // 4. åˆå¹¶å’Œæ’åº
    return this.mergeResults(vectorResults, graphResults, limit)
  }

  /**
   * è®°å¿†æ•´åˆ - å°†çŸ­æœŸè®°å¿†è½¬ä¸ºé•¿æœŸè®°å¿†
   */
  private async consolidateMemory(): Promise<void> {
    // è¯„ä¼°é‡è¦æ€§
    const importantMemories = this.shortTermMemory
      .filter(m => m.metadata.importance > 0.7)
    
    // è½¬ä¸ºé•¿æœŸè®°å¿†
    for (const memory of importantMemories) {
      await this.store({
        ...memory,
        type: MemoryType.LONG_TERM
      })
    }
    
    // æ¸…ç†çŸ­æœŸè®°å¿†
    this.shortTermMemory = this.shortTermMemory
      .filter(m => m.metadata.importance <= 0.7)
      .slice(-50)  // ä¿ç•™æœ€è¿‘50æ¡
  }

  /**
   * ç”Ÿæˆembedding
   */
  private async generateEmbedding(text: string): Promise<number[]> {
    // è°ƒç”¨embeddingæ¨¡å‹
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨æœ¬åœ°æ¨¡å‹æˆ–API
    return await embeddingModel.encode(text)
  }

  /**
   * è·å–ä¼šè¯ä¸Šä¸‹æ–‡
   */
  async getContext(query: string): Promise<string> {
    // 1. è·å–çŸ­æœŸè®°å¿†
    const recentMemories = this.shortTermMemory.slice(-10)
    
    // 2. æ£€ç´¢ç›¸å…³é•¿æœŸè®°å¿†
    const relevantMemories = await this.retrieve(query, 5)
    
    // 3. æ„å»ºä¸Šä¸‹æ–‡
    const context = [
      '## æœ€è¿‘å¯¹è¯',
      ...recentMemories.map(m => m.content),
      '',
      '## ç›¸å…³çŸ¥è¯†',
      ...relevantMemories.map(m => m.content)
    ].join('\n')
    
    return context
  }
}
```

### å‘é‡å­˜å‚¨å®ç°

```typescript
/**
 * å‘é‡å­˜å‚¨ï¼ˆä½¿ç”¨SQLite + VSSæ‰©å±•ï¼‰
 */
export class VectorStore {
  private db: Database

  constructor() {
    this.db = new Database('memory.db')
    this.initialize()
  }

  private initialize(): void {
    this.db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS vectors USING vss0(
        embedding(384)
      );
      
      CREATE TABLE IF NOT EXISTS memory_items (
        id TEXT PRIMARY KEY,
        content TEXT,
        metadata TEXT,
        created_at INTEGER
      );
    `)
  }

  async add(item: MemoryItem): Promise<void> {
    // å­˜å‚¨å‘é‡
    this.db.prepare(`
      INSERT INTO vectors(rowid, embedding)
      VALUES (?, ?)
    `).run(item.id, item.embedding)
    
    // å­˜å‚¨å†…å®¹
    this.db.prepare(`
      INSERT INTO memory_items(id, content, metadata, created_at)
      VALUES (?, ?, ?, ?)
    `).run(
      item.id,
      item.content,
      JSON.stringify(item.metadata),
      Date.now()
    )
  }

  async search(
    queryEmbedding: number[],
    limit: number
  ): Promise<MemoryItem[]> {
    const results = this.db.prepare(`
      SELECT 
        m.id,
        m.content,
        m.metadata,
        v.distance
      FROM vectors v
      JOIN memory_items m ON v.rowid = m.id
      WHERE vss_search(v.embedding, ?)
      ORDER BY v.distance
      LIMIT ?
    `).all(queryEmbedding, limit)
    
    return results.map(row => ({
      id: row.id,
      type: MemoryType.LONG_TERM,
      content: row.content,
      metadata: JSON.parse(row.metadata)
    }))
  }
}
```

---

## ğŸ”’ å®‰å…¨æœºåˆ¶å¢å¼º

### æ“ä½œå®¡è®¡

```typescript
/**
 * å®¡è®¡æ—¥å¿—
 */
export interface AuditLog {
  id: string
  timestamp: number
  agentId: string
  action: string
  tool: string
  parameters: any
  result: 'success' | 'failure' | 'cancelled'
  dangerous: boolean
  userConfirmed?: boolean
}

/**
 * å®¡è®¡ç³»ç»Ÿ
 */
export class AuditSystem {
  private logs: AuditLog[] = []
  private db: Database

  /**
   * è®°å½•æ“ä½œ
   */
  async log(entry: Omit<AuditLog, 'id' | 'timestamp'>): Promise<void> {
    const log: AuditLog = {
      id: generateId(),
      timestamp: Date.now(),
      ...entry
    }
    
    this.logs.push(log)
    
    // æŒä¹…åŒ–
    await this.persist(log)
    
    // å±é™©æ“ä½œå‘Šè­¦
    if (entry.dangerous && entry.result === 'success') {
      await this.alertDangerousOperation(log)
    }
  }

  /**
   * æŸ¥è¯¢å®¡è®¡æ—¥å¿—
   */
  async query(filter: AuditFilter): Promise<AuditLog[]> {
    let results = this.logs
    
    if (filter.agentId) {
      results = results.filter(l => l.agentId === filter.agentId)
    }
    
    if (filter.dangerous !== undefined) {
      results = results.filter(l => l.dangerous === filter.dangerous)
    }
    
    if (filter.startTime) {
      results = results.filter(l => l.timestamp >= filter.startTime!)
    }
    
    return results
  }

  /**
   * ç”Ÿæˆå®¡è®¡æŠ¥å‘Š
   */
  async generateReport(period: 'day' | 'week' | 'month'): Promise<AuditReport> {
    const now = Date.now()
    const periodMs = {
      day: 24 * 60 * 60 * 1000,
      week: 7 * 24 * 60 * 60 * 1000,
      month: 30 * 24 * 60 * 60 * 1000
    }[period]
    
    const logs = this.logs.filter(l => l.timestamp >= now - periodMs)
    
    return {
      period,
      totalOperations: logs.length,
      successfulOperations: logs.filter(l => l.result === 'success').length,
      failedOperations: logs.filter(l => l.result === 'failure').length,
      dangerousOperations: logs.filter(l => l.dangerous).length,
      topTools: this.getTopTools(logs),
      timeline: this.generateTimeline(logs)
    }
  }
}
```

### å›æ»šæœºåˆ¶

```typescript
/**
 * æ“ä½œå¿«ç…§
 */
export interface OperationSnapshot {
  id: string
  timestamp: number
  operation: string
  stateBefore: any
  stateAfter: any
  rollbackScript?: string
}

/**
 * å›æ»šç³»ç»Ÿ
 */
export class RollbackSystem {
  private snapshots: Map<string, OperationSnapshot> = new Map()

  /**
   * åˆ›å»ºå¿«ç…§
   */
  async createSnapshot(
    operation: string,
    stateBefore: any
  ): Promise<string> {
    const snapshot: OperationSnapshot = {
      id: generateId(),
      timestamp: Date.now(),
      operation,
      stateBefore,
      stateAfter: null
    }
    
    this.snapshots.set(snapshot.id, snapshot)
    return snapshot.id
  }

  /**
   * æ›´æ–°å¿«ç…§
   */
  async updateSnapshot(
    id: string,
    stateAfter: any,
    rollbackScript?: string
  ): Promise<void> {
    const snapshot = this.snapshots.get(id)
    if (!snapshot) return
    
    snapshot.stateAfter = stateAfter
    snapshot.rollbackScript = rollbackScript
  }

  /**
   * å›æ»šæ“ä½œ
   */
  async rollback(snapshotId: string): Promise<void> {
    const snapshot = this.snapshots.get(snapshotId)
    if (!snapshot) {
      throw new Error('å¿«ç…§ä¸å­˜åœ¨')
    }
    
    if (snapshot.rollbackScript) {
      // æ‰§è¡Œå›æ»šè„šæœ¬
      await executeScript(snapshot.rollbackScript)
    } else {
      // æ¢å¤çŠ¶æ€
      await restoreState(snapshot.stateBefore)
    }
  }
}
```

---

## ğŸ“Š å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€æ¶æ„ï¼ˆ2å‘¨ï¼‰

- [ ] Agentåè°ƒå™¨å®ç°
- [ ] å¢å¼ºå·¥å…·æ³¨å†Œç³»ç»Ÿ
- [ ] å®¡è®¡ç³»ç»ŸåŸºç¡€

### é˜¶æ®µ2ï¼šå¤šAgentåä½œï¼ˆ2å‘¨ï¼‰

- [ ] ä¸“å®¶Agentå®ç°
- [ ] Agenté—´é€šä¿¡
- [ ] ä»»åŠ¡åˆ†è§£å’Œåˆ†é…

### é˜¶æ®µ3ï¼šè®°å¿†ç³»ç»Ÿï¼ˆ2å‘¨ï¼‰

- [ ] å‘é‡å­˜å‚¨å®ç°
- [ ] è®°å¿†æ•´åˆæœºåˆ¶
- [ ] çŸ¥è¯†å›¾è°±åŸºç¡€

### é˜¶æ®µ4ï¼šå®‰å…¨å¢å¼ºï¼ˆ1å‘¨ï¼‰

- [ ] å›æ»šæœºåˆ¶
- [ ] å®¡è®¡æŠ¥å‘Š
- [ ] å±é™©æ“ä½œç¡®è®¤ä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-02-06
