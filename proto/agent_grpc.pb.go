// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v4.25.1
// source: agent.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentService_Authenticate_FullMethodName     = "/runixo.AgentService/Authenticate"
	AgentService_GetSystemInfo_FullMethodName    = "/runixo.AgentService/GetSystemInfo"
	AgentService_GetMetrics_FullMethodName       = "/runixo.AgentService/GetMetrics"
	AgentService_ExecuteCommand_FullMethodName   = "/runixo.AgentService/ExecuteCommand"
	AgentService_ExecuteShell_FullMethodName     = "/runixo.AgentService/ExecuteShell"
	AgentService_ReadFile_FullMethodName         = "/runixo.AgentService/ReadFile"
	AgentService_WriteFile_FullMethodName        = "/runixo.AgentService/WriteFile"
	AgentService_ListDirectory_FullMethodName    = "/runixo.AgentService/ListDirectory"
	AgentService_DeleteFile_FullMethodName       = "/runixo.AgentService/DeleteFile"
	AgentService_UploadFile_FullMethodName       = "/runixo.AgentService/UploadFile"
	AgentService_DownloadFile_FullMethodName     = "/runixo.AgentService/DownloadFile"
	AgentService_TailLog_FullMethodName          = "/runixo.AgentService/TailLog"
	AgentService_ListServices_FullMethodName     = "/runixo.AgentService/ListServices"
	AgentService_ServiceAction_FullMethodName    = "/runixo.AgentService/ServiceAction"
	AgentService_ListProcesses_FullMethodName    = "/runixo.AgentService/ListProcesses"
	AgentService_KillProcess_FullMethodName      = "/runixo.AgentService/KillProcess"
	AgentService_SearchDockerHub_FullMethodName  = "/runixo.AgentService/SearchDockerHub"
	AgentService_ProxyHttpRequest_FullMethodName = "/runixo.AgentService/ProxyHttpRequest"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AgentService - 核心Agent服务
type AgentServiceClient interface {
	// 认证
	Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// 系统信息
	GetSystemInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SystemInfo, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error)
	// 命令执行
	ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	ExecuteShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ShellInput, ShellOutput], error)
	// 文件操作
	ReadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*FileContent, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	ListDirectory(ctx context.Context, in *DirRequest, opts ...grpc.CallOption) (*DirContent, error)
	DeleteFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 流式文件上传 - 支持大文件
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileChunk, UploadResponse], error)
	// 流式文件下载 - 支持大文件
	DownloadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileChunk], error)
	// 日志流
	TailLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error)
	// 服务管理
	ListServices(ctx context.Context, in *ServiceFilter, opts ...grpc.CallOption) (*ServiceList, error)
	ServiceAction(ctx context.Context, in *ServiceActionRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 进程管理
	ListProcesses(ctx context.Context, in *ProcessFilter, opts ...grpc.CallOption) (*ProcessList, error)
	KillProcess(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// Docker Hub 搜索（通过服务端代理）
	SearchDockerHub(ctx context.Context, in *DockerSearchRequest, opts ...grpc.CallOption) (*DockerSearchResponse, error)
	// HTTP 代理请求（通用）
	ProxyHttpRequest(ctx context.Context, in *HttpProxyRequest, opts ...grpc.CallOption) (*HttpProxyResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, AgentService_Authenticate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetSystemInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SystemInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemInfo)
	err := c.cc.Invoke(ctx, AgentService_GetSystemInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[0], AgentService_GetMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MetricsRequest, Metrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_GetMetricsClient = grpc.ServerStreamingClient[Metrics]

func (c *agentServiceClient) ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, AgentService_ExecuteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ExecuteShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ShellInput, ShellOutput], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[1], AgentService_ExecuteShell_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ShellInput, ShellOutput]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_ExecuteShellClient = grpc.BidiStreamingClient[ShellInput, ShellOutput]

func (c *agentServiceClient) ReadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*FileContent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileContent)
	err := c.cc.Invoke(ctx, AgentService_ReadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, AgentService_WriteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListDirectory(ctx context.Context, in *DirRequest, opts ...grpc.CallOption) (*DirContent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DirContent)
	err := c.cc.Invoke(ctx, AgentService_ListDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeleteFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, AgentService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileChunk, UploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[2], AgentService_UploadFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileChunk, UploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_UploadFileClient = grpc.ClientStreamingClient[FileChunk, UploadResponse]

func (c *agentServiceClient) DownloadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[3], AgentService_DownloadFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileRequest, FileChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_DownloadFileClient = grpc.ServerStreamingClient[FileChunk]

func (c *agentServiceClient) TailLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[4], AgentService_TailLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogRequest, LogLine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_TailLogClient = grpc.ServerStreamingClient[LogLine]

func (c *agentServiceClient) ListServices(ctx context.Context, in *ServiceFilter, opts ...grpc.CallOption) (*ServiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceList)
	err := c.cc.Invoke(ctx, AgentService_ListServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ServiceAction(ctx context.Context, in *ServiceActionRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, AgentService_ServiceAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListProcesses(ctx context.Context, in *ProcessFilter, opts ...grpc.CallOption) (*ProcessList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessList)
	err := c.cc.Invoke(ctx, AgentService_ListProcesses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) KillProcess(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, AgentService_KillProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) SearchDockerHub(ctx context.Context, in *DockerSearchRequest, opts ...grpc.CallOption) (*DockerSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DockerSearchResponse)
	err := c.cc.Invoke(ctx, AgentService_SearchDockerHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ProxyHttpRequest(ctx context.Context, in *HttpProxyRequest, opts ...grpc.CallOption) (*HttpProxyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HttpProxyResponse)
	err := c.cc.Invoke(ctx, AgentService_ProxyHttpRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
//
// AgentService - 核心Agent服务
type AgentServiceServer interface {
	// 认证
	Authenticate(context.Context, *AuthRequest) (*AuthResponse, error)
	// 系统信息
	GetSystemInfo(context.Context, *Empty) (*SystemInfo, error)
	GetMetrics(*MetricsRequest, grpc.ServerStreamingServer[Metrics]) error
	// 命令执行
	ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error)
	ExecuteShell(grpc.BidiStreamingServer[ShellInput, ShellOutput]) error
	// 文件操作
	ReadFile(context.Context, *FileRequest) (*FileContent, error)
	WriteFile(context.Context, *WriteFileRequest) (*ActionResponse, error)
	ListDirectory(context.Context, *DirRequest) (*DirContent, error)
	DeleteFile(context.Context, *FileRequest) (*ActionResponse, error)
	// 流式文件上传 - 支持大文件
	UploadFile(grpc.ClientStreamingServer[FileChunk, UploadResponse]) error
	// 流式文件下载 - 支持大文件
	DownloadFile(*FileRequest, grpc.ServerStreamingServer[FileChunk]) error
	// 日志流
	TailLog(*LogRequest, grpc.ServerStreamingServer[LogLine]) error
	// 服务管理
	ListServices(context.Context, *ServiceFilter) (*ServiceList, error)
	ServiceAction(context.Context, *ServiceActionRequest) (*ActionResponse, error)
	// 进程管理
	ListProcesses(context.Context, *ProcessFilter) (*ProcessList, error)
	KillProcess(context.Context, *KillProcessRequest) (*ActionResponse, error)
	// Docker Hub 搜索（通过服务端代理）
	SearchDockerHub(context.Context, *DockerSearchRequest) (*DockerSearchResponse, error)
	// HTTP 代理请求（通用）
	ProxyHttpRequest(context.Context, *HttpProxyRequest) (*HttpProxyResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) Authenticate(context.Context, *AuthRequest) (*AuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedAgentServiceServer) GetSystemInfo(context.Context, *Empty) (*SystemInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedAgentServiceServer) GetMetrics(*MetricsRequest, grpc.ServerStreamingServer[Metrics]) error {
	return status.Error(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedAgentServiceServer) ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteCommand not implemented")
}
func (UnimplementedAgentServiceServer) ExecuteShell(grpc.BidiStreamingServer[ShellInput, ShellOutput]) error {
	return status.Error(codes.Unimplemented, "method ExecuteShell not implemented")
}
func (UnimplementedAgentServiceServer) ReadFile(context.Context, *FileRequest) (*FileContent, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedAgentServiceServer) WriteFile(context.Context, *WriteFileRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedAgentServiceServer) ListDirectory(context.Context, *DirRequest) (*DirContent, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDirectory not implemented")
}
func (UnimplementedAgentServiceServer) DeleteFile(context.Context, *FileRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedAgentServiceServer) UploadFile(grpc.ClientStreamingServer[FileChunk, UploadResponse]) error {
	return status.Error(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedAgentServiceServer) DownloadFile(*FileRequest, grpc.ServerStreamingServer[FileChunk]) error {
	return status.Error(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedAgentServiceServer) TailLog(*LogRequest, grpc.ServerStreamingServer[LogLine]) error {
	return status.Error(codes.Unimplemented, "method TailLog not implemented")
}
func (UnimplementedAgentServiceServer) ListServices(context.Context, *ServiceFilter) (*ServiceList, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedAgentServiceServer) ServiceAction(context.Context, *ServiceActionRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ServiceAction not implemented")
}
func (UnimplementedAgentServiceServer) ListProcesses(context.Context, *ProcessFilter) (*ProcessList, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProcesses not implemented")
}
func (UnimplementedAgentServiceServer) KillProcess(context.Context, *KillProcessRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KillProcess not implemented")
}
func (UnimplementedAgentServiceServer) SearchDockerHub(context.Context, *DockerSearchRequest) (*DockerSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchDockerHub not implemented")
}
func (UnimplementedAgentServiceServer) ProxyHttpRequest(context.Context, *HttpProxyRequest) (*HttpProxyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ProxyHttpRequest not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Authenticate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Authenticate(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetSystemInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetSystemInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).GetMetrics(m, &grpc.GenericServerStream[MetricsRequest, Metrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_GetMetricsServer = grpc.ServerStreamingServer[Metrics]

func _AgentService_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ExecuteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ExecuteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ExecuteCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ExecuteShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServiceServer).ExecuteShell(&grpc.GenericServerStream[ShellInput, ShellOutput]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_ExecuteShellServer = grpc.BidiStreamingServer[ShellInput, ShellOutput]

func _AgentService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ReadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ReadFile(ctx, req.(*FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_WriteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListDirectory(ctx, req.(*DirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeleteFile(ctx, req.(*FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServiceServer).UploadFile(&grpc.GenericServerStream[FileChunk, UploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_UploadFileServer = grpc.ClientStreamingServer[FileChunk, UploadResponse]

func _AgentService_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).DownloadFile(m, &grpc.GenericServerStream[FileRequest, FileChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_DownloadFileServer = grpc.ServerStreamingServer[FileChunk]

func _AgentService_TailLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).TailLog(m, &grpc.GenericServerStream[LogRequest, LogLine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_TailLogServer = grpc.ServerStreamingServer[LogLine]

func _AgentService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListServices(ctx, req.(*ServiceFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ServiceAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ServiceAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ServiceAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ServiceAction(ctx, req.(*ServiceActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListProcesses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListProcesses(ctx, req.(*ProcessFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_KillProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).KillProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_KillProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).KillProcess(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_SearchDockerHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DockerSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).SearchDockerHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_SearchDockerHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).SearchDockerHub(ctx, req.(*DockerSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ProxyHttpRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ProxyHttpRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ProxyHttpRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ProxyHttpRequest(ctx, req.(*HttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runixo.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authenticate",
			Handler:    _AgentService_Authenticate_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _AgentService_GetSystemInfo_Handler,
		},
		{
			MethodName: "ExecuteCommand",
			Handler:    _AgentService_ExecuteCommand_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _AgentService_ReadFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _AgentService_WriteFile_Handler,
		},
		{
			MethodName: "ListDirectory",
			Handler:    _AgentService_ListDirectory_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _AgentService_DeleteFile_Handler,
		},
		{
			MethodName: "ListServices",
			Handler:    _AgentService_ListServices_Handler,
		},
		{
			MethodName: "ServiceAction",
			Handler:    _AgentService_ServiceAction_Handler,
		},
		{
			MethodName: "ListProcesses",
			Handler:    _AgentService_ListProcesses_Handler,
		},
		{
			MethodName: "KillProcess",
			Handler:    _AgentService_KillProcess_Handler,
		},
		{
			MethodName: "SearchDockerHub",
			Handler:    _AgentService_SearchDockerHub_Handler,
		},
		{
			MethodName: "ProxyHttpRequest",
			Handler:    _AgentService_ProxyHttpRequest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetMetrics",
			Handler:       _AgentService_GetMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteShell",
			Handler:       _AgentService_ExecuteShell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadFile",
			Handler:       _AgentService_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _AgentService_DownloadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TailLog",
			Handler:       _AgentService_TailLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}

const (
	PluginService_ListPlugins_FullMethodName         = "/runixo.PluginService/ListPlugins"
	PluginService_InstallPlugin_FullMethodName       = "/runixo.PluginService/InstallPlugin"
	PluginService_UninstallPlugin_FullMethodName     = "/runixo.PluginService/UninstallPlugin"
	PluginService_EnablePlugin_FullMethodName        = "/runixo.PluginService/EnablePlugin"
	PluginService_DisablePlugin_FullMethodName       = "/runixo.PluginService/DisablePlugin"
	PluginService_GetPluginConfig_FullMethodName     = "/runixo.PluginService/GetPluginConfig"
	PluginService_SetPluginConfig_FullMethodName     = "/runixo.PluginService/SetPluginConfig"
	PluginService_GetPluginStatus_FullMethodName     = "/runixo.PluginService/GetPluginStatus"
	PluginService_GetAvailablePlugins_FullMethodName = "/runixo.PluginService/GetAvailablePlugins"
)

// PluginServiceClient is the client API for PluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 插件服务
type PluginServiceClient interface {
	// 列出已安装的插件
	ListPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginList, error)
	// 安装插件
	InstallPlugin(ctx context.Context, in *InstallPluginRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 卸载插件
	UninstallPlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 启用插件
	EnablePlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 禁用插件
	DisablePlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 获取插件配置
	GetPluginConfig(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginConfig, error)
	// 设置插件配置
	SetPluginConfig(ctx context.Context, in *SetPluginConfigRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 获取插件状态
	GetPluginStatus(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginStatus, error)
	// 获取可用插件列表（从远程仓库）
	GetAvailablePlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailablePluginList, error)
}

type pluginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginServiceClient(cc grpc.ClientConnInterface) PluginServiceClient {
	return &pluginServiceClient{cc}
}

func (c *pluginServiceClient) ListPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginList)
	err := c.cc.Invoke(ctx, PluginService_ListPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) InstallPlugin(ctx context.Context, in *InstallPluginRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, PluginService_InstallPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) UninstallPlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, PluginService_UninstallPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) EnablePlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, PluginService_EnablePlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) DisablePlugin(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, PluginService_DisablePlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetPluginConfig(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginConfig)
	err := c.cc.Invoke(ctx, PluginService_GetPluginConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) SetPluginConfig(ctx context.Context, in *SetPluginConfigRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, PluginService_SetPluginConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetPluginStatus(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginStatus)
	err := c.cc.Invoke(ctx, PluginService_GetPluginStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetAvailablePlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailablePluginList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailablePluginList)
	err := c.cc.Invoke(ctx, PluginService_GetAvailablePlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginServiceServer is the server API for PluginService service.
// All implementations must embed UnimplementedPluginServiceServer
// for forward compatibility.
//
// 插件服务
type PluginServiceServer interface {
	// 列出已安装的插件
	ListPlugins(context.Context, *Empty) (*PluginList, error)
	// 安装插件
	InstallPlugin(context.Context, *InstallPluginRequest) (*ActionResponse, error)
	// 卸载插件
	UninstallPlugin(context.Context, *PluginRequest) (*ActionResponse, error)
	// 启用插件
	EnablePlugin(context.Context, *PluginRequest) (*ActionResponse, error)
	// 禁用插件
	DisablePlugin(context.Context, *PluginRequest) (*ActionResponse, error)
	// 获取插件配置
	GetPluginConfig(context.Context, *PluginRequest) (*PluginConfig, error)
	// 设置插件配置
	SetPluginConfig(context.Context, *SetPluginConfigRequest) (*ActionResponse, error)
	// 获取插件状态
	GetPluginStatus(context.Context, *PluginRequest) (*PluginStatus, error)
	// 获取可用插件列表（从远程仓库）
	GetAvailablePlugins(context.Context, *Empty) (*AvailablePluginList, error)
	mustEmbedUnimplementedPluginServiceServer()
}

// UnimplementedPluginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginServiceServer struct{}

func (UnimplementedPluginServiceServer) ListPlugins(context.Context, *Empty) (*PluginList, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedPluginServiceServer) InstallPlugin(context.Context, *InstallPluginRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InstallPlugin not implemented")
}
func (UnimplementedPluginServiceServer) UninstallPlugin(context.Context, *PluginRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UninstallPlugin not implemented")
}
func (UnimplementedPluginServiceServer) EnablePlugin(context.Context, *PluginRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnablePlugin not implemented")
}
func (UnimplementedPluginServiceServer) DisablePlugin(context.Context, *PluginRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisablePlugin not implemented")
}
func (UnimplementedPluginServiceServer) GetPluginConfig(context.Context, *PluginRequest) (*PluginConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPluginConfig not implemented")
}
func (UnimplementedPluginServiceServer) SetPluginConfig(context.Context, *SetPluginConfigRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetPluginConfig not implemented")
}
func (UnimplementedPluginServiceServer) GetPluginStatus(context.Context, *PluginRequest) (*PluginStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPluginStatus not implemented")
}
func (UnimplementedPluginServiceServer) GetAvailablePlugins(context.Context, *Empty) (*AvailablePluginList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailablePlugins not implemented")
}
func (UnimplementedPluginServiceServer) mustEmbedUnimplementedPluginServiceServer() {}
func (UnimplementedPluginServiceServer) testEmbeddedByValue()                       {}

// UnsafePluginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginServiceServer will
// result in compilation errors.
type UnsafePluginServiceServer interface {
	mustEmbedUnimplementedPluginServiceServer()
}

func RegisterPluginServiceServer(s grpc.ServiceRegistrar, srv PluginServiceServer) {
	// If the following call panics, it indicates UnimplementedPluginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginService_ServiceDesc, srv)
}

func _PluginService_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_ListPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).ListPlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_InstallPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).InstallPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_InstallPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).InstallPlugin(ctx, req.(*InstallPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_UninstallPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).UninstallPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_UninstallPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).UninstallPlugin(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_EnablePlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).EnablePlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_EnablePlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).EnablePlugin(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_DisablePlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).DisablePlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_DisablePlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).DisablePlugin(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetPluginConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetPluginConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetPluginConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetPluginConfig(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_SetPluginConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPluginConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).SetPluginConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_SetPluginConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).SetPluginConfig(ctx, req.(*SetPluginConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetPluginStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetPluginStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetPluginStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetPluginStatus(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetAvailablePlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetAvailablePlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetAvailablePlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetAvailablePlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginService_ServiceDesc is the grpc.ServiceDesc for PluginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runixo.PluginService",
	HandlerType: (*PluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlugins",
			Handler:    _PluginService_ListPlugins_Handler,
		},
		{
			MethodName: "InstallPlugin",
			Handler:    _PluginService_InstallPlugin_Handler,
		},
		{
			MethodName: "UninstallPlugin",
			Handler:    _PluginService_UninstallPlugin_Handler,
		},
		{
			MethodName: "EnablePlugin",
			Handler:    _PluginService_EnablePlugin_Handler,
		},
		{
			MethodName: "DisablePlugin",
			Handler:    _PluginService_DisablePlugin_Handler,
		},
		{
			MethodName: "GetPluginConfig",
			Handler:    _PluginService_GetPluginConfig_Handler,
		},
		{
			MethodName: "SetPluginConfig",
			Handler:    _PluginService_SetPluginConfig_Handler,
		},
		{
			MethodName: "GetPluginStatus",
			Handler:    _PluginService_GetPluginStatus_Handler,
		},
		{
			MethodName: "GetAvailablePlugins",
			Handler:    _PluginService_GetAvailablePlugins_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent.proto",
}

const (
	UpdateService_CheckUpdate_FullMethodName      = "/runixo.UpdateService/CheckUpdate"
	UpdateService_DownloadUpdate_FullMethodName   = "/runixo.UpdateService/DownloadUpdate"
	UpdateService_ApplyUpdate_FullMethodName      = "/runixo.UpdateService/ApplyUpdate"
	UpdateService_GetUpdateConfig_FullMethodName  = "/runixo.UpdateService/GetUpdateConfig"
	UpdateService_SetUpdateConfig_FullMethodName  = "/runixo.UpdateService/SetUpdateConfig"
	UpdateService_GetUpdateHistory_FullMethodName = "/runixo.UpdateService/GetUpdateHistory"
)

// UpdateServiceClient is the client API for UpdateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 更新服务
type UpdateServiceClient interface {
	// 检查更新
	CheckUpdate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateInfo, error)
	// 下载更新
	DownloadUpdate(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadProgress], error)
	// 应用更新
	ApplyUpdate(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	// 获取更新配置
	GetUpdateConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateConfig, error)
	// 设置更新配置
	SetUpdateConfig(ctx context.Context, in *UpdateConfig, opts ...grpc.CallOption) (*ActionResponse, error)
	// 获取更新历史
	GetUpdateHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateHistory, error)
}

type updateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUpdateServiceClient(cc grpc.ClientConnInterface) UpdateServiceClient {
	return &updateServiceClient{cc}
}

func (c *updateServiceClient) CheckUpdate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateInfo)
	err := c.cc.Invoke(ctx, UpdateService_CheckUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DownloadUpdate(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UpdateService_ServiceDesc.Streams[0], UpdateService_DownloadUpdate_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UpdateRequest, DownloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UpdateService_DownloadUpdateClient = grpc.ServerStreamingClient[DownloadProgress]

func (c *updateServiceClient) ApplyUpdate(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, UpdateService_ApplyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetUpdateConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateConfig)
	err := c.cc.Invoke(ctx, UpdateService_GetUpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetUpdateConfig(ctx context.Context, in *UpdateConfig, opts ...grpc.CallOption) (*ActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, UpdateService_SetUpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetUpdateHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UpdateHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateHistory)
	err := c.cc.Invoke(ctx, UpdateService_GetUpdateHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UpdateServiceServer is the server API for UpdateService service.
// All implementations must embed UnimplementedUpdateServiceServer
// for forward compatibility.
//
// 更新服务
type UpdateServiceServer interface {
	// 检查更新
	CheckUpdate(context.Context, *Empty) (*UpdateInfo, error)
	// 下载更新
	DownloadUpdate(*UpdateRequest, grpc.ServerStreamingServer[DownloadProgress]) error
	// 应用更新
	ApplyUpdate(context.Context, *UpdateRequest) (*ActionResponse, error)
	// 获取更新配置
	GetUpdateConfig(context.Context, *Empty) (*UpdateConfig, error)
	// 设置更新配置
	SetUpdateConfig(context.Context, *UpdateConfig) (*ActionResponse, error)
	// 获取更新历史
	GetUpdateHistory(context.Context, *Empty) (*UpdateHistory, error)
	mustEmbedUnimplementedUpdateServiceServer()
}

// UnimplementedUpdateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUpdateServiceServer struct{}

func (UnimplementedUpdateServiceServer) CheckUpdate(context.Context, *Empty) (*UpdateInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckUpdate not implemented")
}
func (UnimplementedUpdateServiceServer) DownloadUpdate(*UpdateRequest, grpc.ServerStreamingServer[DownloadProgress]) error {
	return status.Error(codes.Unimplemented, "method DownloadUpdate not implemented")
}
func (UnimplementedUpdateServiceServer) ApplyUpdate(context.Context, *UpdateRequest) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyUpdate not implemented")
}
func (UnimplementedUpdateServiceServer) GetUpdateConfig(context.Context, *Empty) (*UpdateConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUpdateConfig not implemented")
}
func (UnimplementedUpdateServiceServer) SetUpdateConfig(context.Context, *UpdateConfig) (*ActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUpdateConfig not implemented")
}
func (UnimplementedUpdateServiceServer) GetUpdateHistory(context.Context, *Empty) (*UpdateHistory, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUpdateHistory not implemented")
}
func (UnimplementedUpdateServiceServer) mustEmbedUnimplementedUpdateServiceServer() {}
func (UnimplementedUpdateServiceServer) testEmbeddedByValue()                       {}

// UnsafeUpdateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UpdateServiceServer will
// result in compilation errors.
type UnsafeUpdateServiceServer interface {
	mustEmbedUnimplementedUpdateServiceServer()
}

func RegisterUpdateServiceServer(s grpc.ServiceRegistrar, srv UpdateServiceServer) {
	// If the following call panics, it indicates UnimplementedUpdateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UpdateService_ServiceDesc, srv)
}

func _UpdateService_CheckUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CheckUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UpdateService_CheckUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CheckUpdate(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DownloadUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UpdateServiceServer).DownloadUpdate(m, &grpc.GenericServerStream[UpdateRequest, DownloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UpdateService_DownloadUpdateServer = grpc.ServerStreamingServer[DownloadProgress]

func _UpdateService_ApplyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ApplyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UpdateService_ApplyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ApplyUpdate(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetUpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetUpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UpdateService_GetUpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetUpdateConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetUpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetUpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UpdateService_SetUpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetUpdateConfig(ctx, req.(*UpdateConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetUpdateHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetUpdateHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UpdateService_GetUpdateHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetUpdateHistory(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// UpdateService_ServiceDesc is the grpc.ServiceDesc for UpdateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UpdateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "runixo.UpdateService",
	HandlerType: (*UpdateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckUpdate",
			Handler:    _UpdateService_CheckUpdate_Handler,
		},
		{
			MethodName: "ApplyUpdate",
			Handler:    _UpdateService_ApplyUpdate_Handler,
		},
		{
			MethodName: "GetUpdateConfig",
			Handler:    _UpdateService_GetUpdateConfig_Handler,
		},
		{
			MethodName: "SetUpdateConfig",
			Handler:    _UpdateService_SetUpdateConfig_Handler,
		},
		{
			MethodName: "GetUpdateHistory",
			Handler:    _UpdateService_GetUpdateHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadUpdate",
			Handler:       _UpdateService_DownloadUpdate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}
